'''
Задача 4. Стек
В программировании нередко необходимо создавать свои собственные
структуры данных на основе уже существующих. Одной из таких базовых
структур является стек.
Стек — это абстрактный тип данных, представляющий собой список элементов,
организованных по принципу LIFO (англ. last in — first out, «последним пришёл —
первым вышел»).
Простой пример: стек из книг на столе. Единственной книгой, обложка которой
видна, является самая верхняя. Чтобы получить доступ, например, к третьей
снизу книге, нам нужно убрать все книги, лежащие сверху, одну за другой.
Напишите класс, который реализует стек и его возможности (достаточно будет
добавления и удаления элемента).
После этого напишите ещё один класс — «Менеджер задач». В менеджере задач
можно выполнить команду «новая задача», в которую передаётся сама задача
(str) и её приоритет (int). Сам менеджер работает на основе стека (не
наследование). При выводе менеджера в консоль все задачи должны быть
отсортированы по следующему приоритету: чем меньше число, тем выше задача.
Вот пример основной программы:
manager = TaskManager()
manager.new_task("сделать уборку", 4)
manager.new_task("помыть посуду", 4)
manager.new_task("отдохнуть", 1)
manager.new_task("поесть", 2)
manager.new_task("сдать ДЗ", 2)
print(manager)
Результат:
1 — отдохнуть
2 — поесть; сдать ДЗ
4 — сделать уборку; помыть посуду
Дополнительно: реализуйте также удаление задач и подумайте, что делать с
дубликатами.
Подсказка № 1
Используйте словари для хранения задач. В классе TaskManager можно использовать
словарь для хранения стеков задач, где ключом будет приоритет, а значением — стек
задач с этим приоритетом.
Подсказка № 2
Реализуйте метод для удаления задач. Добавьте метод в класс TaskManager, который
будет удалять задачу по её тексту, независимо от приоритета.
Подсказка № 3
Избегайте дубликатов в стеках. Если вы не хотите, чтобы в стеке были дубликаты
задач, проверьте перед добавлением, содержится ли задача уже в стеке.
Подсказка № 4
Сортировка по приоритету. Для корректного вывода задач по приоритету, отсортируйте
ключи словаря по возрастанию и выводите задачи, начиная с наименьшего
приоритета.
'''

class Stack:
   def __init__(self):
      self.items = []

   def push(self, item):
      self.items.append(item)

   def pop(self):
      if not self.is_empty():
         return self.items.pop()
      return None

   def is_empty(self):
      return len(self.items) == 0

   def __str__(self):
      return str(self.items)

class TaskManager:
   def __init__(self):
      self.tasks = {}

   def new_task(self, task, priority):
      if priority not in self.tasks:
         self.tasks[priority] = Stack()
      if task not in self.tasks[priority].items:
         self.tasks[priority].push(task)

   def remove_task(self, task):
      for priority in self.tasks:
         if task in self.tasks[priority].items:
            self.tasks[priority].items.remove(task)
         if self.tasks[priority].is_empty():
            del self.tasks[priority]
            break

   def __str__(self):
      result = []
      for priority in sorted(self.tasks):
         tasks = '; '.join(self.tasks[priority].items)
         result.append(f"{priority} — {tasks}")
         return '\n'.join(result)

# Пример использования
manager = TaskManager()
manager.new_task("сделать уборку", 4)
manager.new_task("помыть посуду", 4)
manager.new_task("отдохнуть", 1)
manager.new_task("поесть", 2)
manager.new_task("сдать ДЗ", 2)

print(manager)

# Удаление задачи
manager.remove_task("поесть")
print("\nПосле удаления задачи 'поесть':")
print(manager)

# Этот код создает класс Stack для реализации стека и класс TaskManager для управления задачами с учетом приоритетов. В классе TaskManager используется словарь для хранения стеков задач, где ключом является приоритет, а значением — стек задач с этим приоритетом. Также реализован метод для удаления задач и предотвращения дубликатов.
